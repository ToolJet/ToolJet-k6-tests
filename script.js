/*
 * ToolJet
 * The tooljet API endpoints
 *
 * OpenAPI spec version: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://github.com/OpenAPITools/openapi-generator
 *
 * OpenAPI generator version: 5.2.1-SNAPSHOT
 */

import http from 'k6/http';
import { group, check, sleep, fail } from 'k6';

export let options = {
  scenarios: {
    sanity_flow: {
      executor: 'per-vu-iterations',
      exec: 'sanityFlow',
      vus: 1,
      iterations: 1,
    },
    data_query_run_flow: {
      exec: 'dataQueryRunFlow',
      // executor: 'per-vu-iterations',
      // vus: 1000,
      // iterations: 1,
      // maxDuration: '10m',

      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '30s', target: 1000 },
        { duration: '5s', target: 0 },
      ],
      gracefulRampDown: '0s',
    }
  }
};

// Sleep duration between successive requests.
// You might want to edit the value of this variable or remove calls to the sleep function on the script.
const SLEEP_DURATION = 0.1;
// Global variables should be initialized.
const BASE_URL = __ENV.BASE_URL || 'http://localhost:3000/api';
const EMAIL = 'dev@tooljet.io';
const PASSWORD = 'password';

let APP_ID;
let DATA_SOURCE_ID;
let DATA_QUERY_ID;

function runGroups(group) {
  const groups = __ENV.RUN_GROUPS.split(',');
  if (groups.includes('all')) return true;
  if (groups.includes(group)) return true;

  return false;
}

// setup is called only once per test
export function setup() {
  const response = authenticate();
  const authToken = response.json().auth_token;
  let dataQueryRun = {};

  if (runGroups('data_query_run_flow')) {
    dataQueryRun = setupApp(authToken);
  }

  return {authToken, dataQueryRun};
}

function randomString(length) {
  const charset = 'abcdefghijklmnopqrstuvwxyz';
  let res = '';
  while (length--) res += charset[(Math.random() * charset.length) | 0];
  return res;
}

function authenticate() {
  const url = BASE_URL + `/authenticate`;
  const headers = { headers: { 'Content-Type': 'application/json' } };
  const payload = JSON.stringify({
    email: EMAIL,
    password: PASSWORD,
  });

  return http.post(url, payload, headers);
}

function mysqlConfig() {
  return [
    {
      key: 'host',
      value: __ENV.MYSQL_HOST,
    },
    {
      key: 'port',
      value: __ENV.MYSQL_PORT,
    },
    {
      key: 'database',
      value: __ENV.MYSQL_DB,
    },
    {
      key: 'username',
      value: __ENV.MYSQL_USER,
    },
    {
      key: 'password',
      value: __ENV.MYSQL_PASSWORD,
      encrypted: true,
    },
  ];
}


function pgConfig() {
  return [
    {
      key: 'host',
      value: __ENV.PG_HOST,
    },
    {
      key: 'port',
      value: __ENV.PG_PORT,
    },
    {
      key: 'database',
      value: __ENV.PG_DB,
    },
    {
      key: 'username',
      value: __ENV.PG_USER,
    },
    {
      key: 'password',
      value: __ENV.PG_PASSWORD,
      encrypted: true,
    },
  ];
}

function setupApp(authToken) {
  // create app
  const headers = {
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${authToken}`,
    },
  };
  let payload = JSON.stringify({
    name: 'Data Query Flow',
  });
  let url = BASE_URL + '/apps';
  let response = http.post(url, payload, headers);
  const appID = response.json().id;

  sleep(SLEEP_DURATION);

  // create data source
  payload = JSON.stringify({
    app_id: appID,
    name: 'PostgreSQL',
    kind: 'postgresql',
    options: pgConfig(),
  });
  url = BASE_URL + '/data_sources';
  response = http.post(url, payload, headers);

  const dataSourceID = response.json().id;
  sleep(SLEEP_DURATION);

  // create data query
  payload = JSON.stringify({
    app_id: appID,
    name: 'postgresloadtest',
    kind: 'postgresql',
    options: {
      query: __ENV.DATA_QUERY,
      runOnPageLoad: true,
    },
    data_source_id: dataSourceID,
  });
  url = BASE_URL + '/data_queries';
  response = http.post(url, payload, headers);

  const dataQueryID = response.json().id;

  sleep(SLEEP_DURATION);

  return {appID, dataSourceID, dataQueryID};
}

function deleteAppAfterTest(authToken, appId) {
  const headers = {
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${authToken}`,
    },
  };
  const url = BASE_URL + `/apps/${appId}`;

  let response = http.del(url, null, headers);

  check(response, {
    'app deleted successfully': (r) => r.status === 200,
  });
}

export function sanityFlow({authToken}) {
  if (runGroups('sanity_flow') == false) fail();

  group('unit tests', () => {
    group('POST /authenticate', () => {
      const response = authenticate();

      check(response, {
        'authenticated successfully': (r) => r.status === 201,
        'authentication returns auth token': (r) => !!r.json().auth_token,
      });

      sleep(SLEEP_DURATION);
    });

    group('/apps', () => {
      let SLUG = randomString(10);

      group('POST /apps', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };
        const payload = JSON.stringify({});
        const url = BASE_URL + '/apps';
        let response = http.post(url, payload, headers);

        check(response, {
          'app create returns 201': (r) => r.status === 201,
          'app created with default values': (r) =>
            r.json().name == 'Untitled app',
        });

        APP_ID = response.json().id;

        sleep(SLEEP_DURATION);
      });

      group('GET /apps/:id', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };
        const url = BASE_URL + `/apps/${APP_ID}`;
        let response = http.get(url, headers);

        check(response, {
          'app show returns 200': (r) => r.status === 200,
        });

        sleep(SLEEP_DURATION);
      });

      group('PATCH /apps/:id', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };

        const payload = JSON.stringify({
          app: {
            name: 'Loadtest app',
            slug: SLUG,
          },
        });

        const url = BASE_URL + `/apps/${APP_ID}`;
        let response = http.put(url, payload, headers);

        check(response, {
          'app update returns 200': (r) => r.status === 200,
        });

        sleep(SLEEP_DURATION);
      });

      group('GET /apps/slugs/:slug', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };
        const url = BASE_URL + `/apps/slugs/${SLUG}`;
        let response = http.get(url, headers);

        check(response, {
          'app show by slug returns 200': (r) => r.status === 200,
        });

        sleep(SLEEP_DURATION);
      });
    });

    group('/data_sources', () => {
      group('POST /data_sources', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };
        const payload = JSON.stringify({
          app_id: APP_ID,
          name: 'PostgreSQL',
          kind: 'postgresql',
          options: pgConfig(),
        });
        const url = BASE_URL + '/data_sources';
        let response = http.post(url, payload, headers);

        check(response, {
          'data source create returns 201': (r) => r.status === 201,
        });

        DATA_SOURCE_ID = response.json().id;

        sleep(SLEEP_DURATION);
      });
    });

    group('/data_queries', () => {
      group('POST /data_queries', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };
        const payload = JSON.stringify({
          app_id: APP_ID,
          name: 'mysqlloadtest',
          kind: 'mysql',
          options: {
            query: 'select * from data limit 50',
            runOnPageLoad: true,
          },
          data_source_id: DATA_SOURCE_ID,
        });
        const url = BASE_URL + '/data_queries';
        let response = http.post(url, payload, headers);

        check(response, {
          'data query create returns 201': (r) => r.status === 201,
        });

        DATA_QUERY_ID = response.json().id;

        sleep(SLEEP_DURATION);
      });

      group('POST /data_queries/:id/run', () => {
        const headers = {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${authToken}`,
          },
        };

        const payload = JSON.stringify({
          options: {},
        });

        const url = BASE_URL + `/data_queries/${DATA_QUERY_ID}/run`;
        let response = http.post(url, payload, headers);

        // console.log(response.body);

        check(response, {
          'data query run returns 201': (r) => r.status === 201,
          'data query run returns query result': (r) => r.json().data !== [],
        });

        sleep(SLEEP_DURATION);
      });
    });

    // teardown for specific app creaated
    deleteAppAfterTest(authToken, APP_ID);
  });
}

export function dataQueryRunFlow({authToken, dataQueryRun}) {
  group('user runs specific data query', () => {
    const headers = {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${authToken}`,
      },
    };

    const payload = JSON.stringify({
      options: {},
    });


    const url = BASE_URL + `/data_queries/${dataQueryRun.dataQueryID}/run`;
    let response = http.post(url, payload, headers);

    check(response, {
      'data query run returns 201': (r) => r.status === 201,
      'data query run returns query result': (r) => r.json().data !== [],
    });

    sleep(SLEEP_DURATION);
  });
}
